///
/// @file       ModelSpecific.cpp
///
///             A file that is expected to change between models and DLLs.
///             It provides the model-specific setup functions to determine
///             the initialization and processing requirements of the model.
///             SetupInitialization() and SetupProcessing() must be provided
///             . These may be empty, or involve high-complexity code - it
///             depends on the model's requirements.
///
/// @ingroup    CoreTrainSim
///
/// @author     James Errington
///
/// @copyright  (C) Copyright:  SYDAC Pty Ltd, 2015
///
  
#include "ModelSpecific.h"
 
#include "model_dll/DataManager.h"
#include "model_dll/ObjectDB.h"
#include "model_dll/ProcessingManager.h"
#include "model_dll/VariableMapper.h"

#include "model_dll/CallbackManager.h"

#include "train_types/InitializationTypes.h"
#include "model_dll/ModelDLLImpl.h"

// Our tasks
#include "model_dll/FeatureAdjacencyTask.h"

#include "project_comms_structure/ProjectObjectConstants.h"

#include "model_dll/MemoryMapping.h"

#include <fstream>
#include <iostream>

#include <conio.h>

#include <limits>
#include <memory>
#include <vector>
#include <cstdint>

using std::vector;
using Initialization::Extract;

// HACK
std::ofstream g_log("coupling.csv");
// RegisterMemoryMap.cpp provides this
void RegisterMemoryMap(MemoryMapping &mm, ModelResource &model);

// RegisterModel.cpp provides this
namespace Registration
{
    // These will be autogenerated, and so should be in RegisterModel
    void           DefineObjects(ModelResource &resource, ObjectDB &db);
    const char    *GetModelTitle();
    uint64_t       GetModelVersion();
}

// RUN CYCLE TIMER

// This is referenced by the MATLAB model in its importing/instrumentation step
// The goal is to accurately measure how much CPU the model requires.
// If this is too higher a percentage then the model will be unsafe to run alongside other modules.

// We want to measure how much CPU is being used - the number of clock cycles.
// Cycles cannot readily be converted to time as the cycles per second can vary.
// See http://blogs.technet.com/b/winserverperformance/archive/2009/08/06/interpreting-cpu-utilization-for-performance-analysis.aspx
// Apparently thread times are based on sampling (every 15.625ms 1/64 second), which explains their inaccuracy - particularly bad if the thread
// runs in bursts. Although sampling is the only way possible to get timing, the limited resolution of 15.6ms must be acknowledged.
// If only considering samples in one section under investigation, it could completely miss it (up to 2x variance was noted in trials).
// If considering the entire thread's performance over the period there was still variance and could not find any reliable way of measuring
// an average time per clock cycle over the last second. Also in this note that the method may be called by several different threads.
// Using the high performance counter is unreliable because the thread can be interrupted if runs for longer than its time slice
// which is guaranteed if the thread is also doing other things in the time slice. (Consistently 2x was noted in trials).

// So in order to indicate timing, we use the maximum CPU, assuming it would ramp up, but there is no standard API for this given that not
// all CPUs may perform that way. Tests indicated that QueryPerformanceFrequency may work, so using that.

namespace
{
    // Information stored per cycle scope
    struct CycleInfo
    {
        ULONG64 cycle_start;
        ULONG64 cycles;
        size_t  count;

        CycleInfo()
            : cycle_start(0), cycles(0), count(0)
        {
        }
    };

    std::map<std::string, CycleInfo> g_cycle_info;
}

// Specify the number of model cycles that we should let go by before we check the keyboard.
// The keyboard checks with thus occur at a frequency of 1 / (model_period * count), or at a period
// of model_period * count.
const int KEYBOARD_CHECK_COUNT = 1000;

#ifdef LOG_TO_FILE
const int LOG_CHECK_COUNT = 50;
#endif //LOG_TO_FILE

/// A cycle has started
void RunCycleTimerStart(const char *name)
{
    ::QueryThreadCycleTime(::GetCurrentThread(), &g_cycle_info[name].cycle_start);
}

/// A cycle has ended
void RunCycleTimerEnd(const char *name)
{
    ULONG64 cycle_end;
    ::QueryThreadCycleTime(::GetCurrentThread(), &cycle_end);

    auto &ci = g_cycle_info[name];
    ++ci.count;
    ci.cycles += cycle_end - ci.cycle_start;
}

namespace
{
    /// Helper class for measuring time spent in RunCycle so as to provide logs to indicate this. This allows a modeller to quickly see
    /// the impact from their model generation settings, but also can indicate the potential for the model to drop if the time being
    /// spent is too high or borderline.
    class RunCycleTimer
    {
    public:
        RunCycleTimer()
            : m_most_cycles(0), m_time(0.0)
        {
            g_cycle_info.clear();
        }

        void RunCycleStart()
        {
            RunCycleTimerStart("RunCycle");
        }

        void RunCycleEnd(double period)
        {
            RunCycleTimerEnd("RunCycle");

            // Measure over a second
            m_time += period;
            if(m_time >= 1.0)
            {
                // We included ourselves, and then can use our details
                // Note the results will include child calls. We presume no recursion
                auto cycles = g_cycle_info["RunCycle"].cycles;

                if(m_most_cycles == 0 || cycles > m_most_cycles)
                {
                    // Log again if the total usage is 1% CPU greater
                    
                    // Get the CPU frequency - once again there is no guarantee we ran at that rate, but we want a worst case measure.
                    // The following gets the actual CPU
                    // wmic cpu get name,CurrentClockSpeed,MaxClockSpeed
                    // The following will surely be incorrect on some CPUs
                    LARGE_INTEGER f;
                    QueryPerformanceFrequency(&f);
                    double freq = static_cast<double>(f.QuadPart) * 1024.0;

                    if(m_most_cycles == 0 || ((cycles - m_most_cycles) * 100.0 >= freq))
                    {
                        m_most_cycles = cycles;
                        std::stringstream ss;
                        ss << "Running at " << (100.0 * cycles / freq / m_time) << "% assuming a CPU of " << (freq / 1000000000.0) << "GHz, cycles = " << cycles;

                        // Sort descending
                        std::vector<std::pair<ULONG64, std::string>> sorted_cycle_info;
                        for(auto i : g_cycle_info)
                        {
                            if(i.first != "RunCycle")
                                sorted_cycle_info.push_back(std::make_pair(i.second.cycles, i.first));
                        }
                        std::sort(sorted_cycle_info.rbegin(), sorted_cycle_info.rend());
                        for(auto i : sorted_cycle_info)
                            ss <<"\n" <<  i.second << " - " << (100.0 * g_cycle_info[i.second].cycles / freq / m_time) << "% cycles = " << g_cycle_info[i.second].cycles << " (" << g_cycle_info[i.second].count << " calls)";

                        DLLModel::Log(ss.str());
                    }
                }

                m_time = 0.0;
                g_cycle_info.clear();
            }
        }

    private:
        ULONG64 m_most_cycles;
        double  m_time;
    };


    // == HELPER FUNCTIONS =================================================

    /// Runs through the object definition and returns the initial value associated with the
    /// number requested.
    ///
    /// @param oi            Describes the object to search through
    /// @param name          The name of the Number to get the initial value of
    /// @param default_value The value to use if the Number could not be found.
    ///
    /// @return The initial value of the Number requested, or the default value provided if the
    ///         Number does not belong to the object.

    double GetNumberInitial(const ObjectDB::ObjectInfo &oi, const std::string &name, double default_value)
    {
        for(const auto &i : oi.numbers)
        {
            if(i.name == name)
                return i.initial;
        }

        // If we didn't find the number then return the default value
        return default_value;
    }

	/// Runs through the object definition and returns the DB value associated with the
    /// number requested.
    ///
    /// @param oi            Describes the object to search through
    /// @param name          The name of the Number to get the value of
    /// @param default_value The value to use if the Number could not be found.
    ///
    /// @return The object database value of the Number requested, or the default value provided if the
    ///         Number does not belong to the object.

    double GetNumberValue(const ObjectDB::ObjectInfo &oi, const std::string &name, double default_value)
    {
        for(const auto &i : oi.numbers)
        {
            if(i.name == name)
                return *i.value;
        }

        // If we didn't find the number then return the default value
        return default_value;
    }
    /// Copies memory blocks, hopefully could be integrated with the MemoryDefinition
    class MemBlockCopy
    {
    public:
        /// Establishes where the memory blocks will be copied from
        template<typename T>
        MemBlockCopy(T &dest)
            : dest(reinterpret_cast<char*>(&dest))
        {
        }

        /// Adds a member to be copied
        template<typename M>
        void Add(M &dest_member)
        {
            MemBlock mb;
            mb.offset = reinterpret_cast<char*>(&dest_member) - dest;
            mb.data.assign(reinterpret_cast<char*>(&dest_member), reinterpret_cast<char*>(&dest_member) + sizeof(dest_member));
            blocks.push_back(mb);
        }

        /// Copies back to the original memory the saved blocks
        void Copy()
        {
            for(auto &mb : blocks)
                memcpy(dest + mb.offset, &mb.data[0], mb.data.size());
        }

    private:
        char *dest;

        struct MemBlock
        {
            size_t offset;
            std::vector<char> data;
        };

        std::vector<MemBlock> blocks;
    };

    // Maps variables of the model data so that they can be logged and accessed
    void InitializeMemoryMap(MemoryMapping &mm, ModelResource &model)
    {
        // Custom registration first
        mm.Register<unsigned char>([] (std::ostream &ss, const char *p) { ss << static_cast<int>(*reinterpret_cast<const unsigned char*>(p)); } );
        mm.RegisterStruct(model.Model().BEML_EMU_M.Timing);

        RegisterMemoryMap(mm, model);

        // Custom mappings follow
        mm.Add("BEML_EMU_M.Timing", model.Model().BEML_EMU_M.Timing);

        // Shortcut method for a single variable - name description isn't pretty though
        ADD_MEMORY_MAPPING(mm, model.Model().BEML_EMU_Y.ModelStatus.IsInitialized);
    }
}

class BEML_EMUDLLModel : public ModelResource, public OperationProcessing, public RegistrationProcessing, public InstancedDLLModel
{
public:
    BEML_EMUDLLModel()
      : ModelResource(m_model_data),
        m_feature_task(GetAdjacencyTypes(),
          FunctionDataArray([&](int i) { return &ModelOutputs().DynamicsOutput[i].Inertia.Position; }),
          FunctionDataArray([&](int i) { return &ModelInputs().VehicleConfig[i].Common.Length; })),
          m_num_vehicles(0),
          m_kb_timer(0)
#ifdef LOG_TO_FILE
          ,m_log_timer(0),
          m_log("TrainModelLog.csv")
#endif //LOG_TO_FILE
    {
    }

    static double GetPeriod()
    {
        return 0.001;
    }

    void RunCycle();

    void DefineObjects(ObjectDB &object_db)
    {
        Registration::DefineObjects(*this, object_db);
    }

private:
    int m_num_vehicles;
    double tdo_vehicle_orientation[158];

    // A timer so that we check the keyboard at a lower frequency
    int m_kb_timer;

#ifdef LOG_TO_FILE
    int m_log_timer;
    std::ofstream m_log;
#endif //LOG_TO_FILE

    std::unique_ptr<MemoryMapping>           m_memory_map;
    std::unique_ptr<SerialisedMemoryMapping> m_serialised_memory;

public:
    /// Called with the current simulation time, corresponding to the time of the last completed
    /// cycle (and the time that the current outputs can be assumed to apply to).
    /// A project may handle this as it desires.
    ///
    /// @param time The current simulation time, in seconds.

    void SetModelSimulationTime(double time) override
    {
        // A project may like to write this time into a variable if it so desires
        // A project will need to write this time into a variable for Coupling with Mimic Models to work
        ModelInputs().SimData.SimulationTime = time;
    }

    //
    // We could do better with saving state. We could only store the input/outputs. We could
    // also store the structure with the hope of mapping across to a new model with extra i/o.
    // We can also avoid saving off information on vehicles that aren't used.
    //


    /// Called to get a pointer to the state. It should be presumed that this pointer will be
    /// valid until GetState is called again, or until anything in the model is change (either
    /// by running a cycle or changing inputs or data). Ownership is not to be assumed by the
    /// receiving code.
    ///
    /// @return A pointer to the bytes that hold the model's current state

    size_t GetState(void *data, size_t size) override
    {
        return m_serialised_memory->GetState(data, size);
    }

    /// Called to set the state of the model. The data will be copied or applied otherwise as
    /// necessary to make the model assume this state, so that the contents of that return by
    /// GetState(), if called immediately, would be identical.
    ///
    /// @param data Points to the bytes holding the state that we want to set the model to

    bool SetState(const void *data, size_t size) override
    {
        SerialisedMemoryMappingReader reader;
        if(!reader.SetState(data, size))
            return false;
        if(reader.GetVersion() != Registration::GetModelVersion())
        {
            DLLModel::Log("Incompatible Version");
            return false;
        }

        m_memory_map->SetState(reader.GetData());

        // This is where we put custom knowledge of our model, and we happen to know that if we
        // leave mx_stable false this will reset our positions, which we don't want!
        mx_stable = true;
        return true;
    }

public:
    // == INITIALIZATION FUNCTIONS =========================================

    void InitializeTrainInfo(DataManager::DataInfo info);

    /// The completion function. We are complete if the initialization parameters have been
    /// set. This will be indicated by having a non-zero number of vehicles
    ///
    /// @return True if initialization is complete.

    bool IsComplete()
    {
        return m_num_vehicles != 0;
    }

    /// The reset function. We set the number of vehicles to zero to indicate that we have not
    /// been initialized yet.

    void Reset()
    {
        m_num_vehicles = 0;

        InstancedDLLModel::Reset();
    }

public:
    // Registration

    void SetupInitialization(DataManager &mgr) override;
    void SetupProcessing(ProcessingManager &mgr) override;
    void CompleteInitialization() override;

private:
    FeatureAdjacencyTask::Config2 GetAdjacencyTypes()
    {
        FeatureAdjacencyTask::Config2 ret;
//        ret.push_back(FeatureAdjacencyTask::Config2::value_type("APC Magnet",      FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.APC.APCMagnet; }),       2.0, 8.0));
       ret.push_back(FeatureAdjacencyTask::Config2::value_type("Neutral Section", FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.NeutralSection; }),  0.0, 0.0));
	   ret.push_back(FeatureAdjacencyTask::Config2::value_type("Obstruction Fixed OLE", FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.DamagedOHE; }),  0.0, 18.0));
	   ret.push_back(FeatureAdjacencyTask::Config2::value_type("Obstruction On Track", FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.ObstructionOnTrack; }),  0.0, 18.0));
	   ret.push_back(FeatureAdjacencyTask::Config2::value_type("Obstruction Soft Collision", FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.ObstructionSoftCollision; }), 0.0, 18.0));
//        ret.push_back(FeatureAdjacencyTask::Config2::value_type("AWS Magnet",      FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.AWSTPWS.AWSMagnet; }),   2.0, 8.0));
//        ret.push_back(FeatureAdjacencyTask::Config2::value_type("TPWS OSS Trip",   FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.AWSTPWS.TPWSOSSTrip; }), 2.0, 8.0));
//        ret.push_back(FeatureAdjacencyTask::Config2::value_type("TPWS TSS Trip",   FunctionDataArray([&](int i) { return &ModelInputs().VehicleInput[i].Environment.AWSTPWS.TPWSTSSTrip; }), 0.0, 4.0));
        return ret;
    }

private:
    BEML_EMUModelClass m_model_data;
    FeatureAdjacencyTask    m_feature_task;

    RunCycleTimer m_cycle_timer;
};

/// Called whenever the corresponding initialization data is provided to the DLL. This
/// sets up the MatrixX variables according to the incoming information, and then returns
/// whether we were successful or not.
///
/// @param info  Describes the incoming initialization info.
///
/// @return True if successful.

void BEML_EMUDLLModel::InitializeTrainInfo(DataManager::DataInfo info)
{
    // As we load in each vehicle from the raw data we will set the
    // corresponding information in the model.
    unsigned int num_vehicles;
    void         *pdata = info.pdata;

    // Extract the number of vehicles
    pdata = Extract(pdata, num_vehicles);

    m_num_vehicles = num_vehicles;
    m_feature_task.SetNumberVehicles(num_vehicles);

    // Extract and set each vehicle
    for(unsigned int i = 0; i < num_vehicles; ++i)
    {
        // Because the structures a single extract is good enough
        Initialization::VehicleInfo vehicle_info;
        pdata = Extract(pdata, vehicle_info);

        auto &config = ModelInputs().VehicleConfig[i];

        // Set these variables in the model
        // Enums should have the correct contents from MATLAB
        config.Common.Enabled       = vehicle_info.vehicle_type > 0;
        config.Common.VehicleID     = vehicle_info.vehicle_id;
        config.Common.Type          = static_cast<VehicleType>(vehicle_info.vehicle_type);
        config.Common.Class         = vehicle_info.vehicle_class;  
        config.Common.Orientation   = vehicle_info.orientation;
        config.Common.Length        = vehicle_info.length;
        config.Common.Height        = vehicle_info.height;
        config.Common.Width         = vehicle_info.width;
        config.Common.TareMass      = vehicle_info.tare;
        config.Common.GrossMass     = vehicle_info.gross;
        config.Common.LoadingMass   = vehicle_info.loading;
        config.Common.WheelDiameter = vehicle_info.diameter * 0.001; // Diameter is stored in mm in the Database but we want SI units
        config.Common.NumberOfAxles = 4;

        if (vehicle_info.orientation == 2)
        {
            ModelInputs().VehicleInput[i].Couplers.Coupler[0].CouplingPhysical.End = 0.0;
            ModelInputs().VehicleInput[i].Couplers.Coupler[1].CouplingPhysical.End = 1.0;
        }
        else
        {
            ModelInputs().VehicleInput[i].Couplers.Coupler[0].CouplingPhysical.End = 1.0;
            ModelInputs().VehicleInput[i].Couplers.Coupler[1].CouplingPhysical.End = 0.0;
        }
    }
}

/// Called on intiialization of the DLL to register the desired initialization parameters
/// and their callbacks.
///
/// @param pmgr  The manager to register the parameters with

void BEML_EMUDLLModel::SetupInitialization(DataManager &mgr)
{
    // Register our train info parameter
    mgr.AddParam("Train Information", std::bind(&BEML_EMUDLLModel::InitializeTrainInfo, this, std::placeholders::_1));

    m_feature_task.SetupInitialization(mgr);

    // Register the feature types that we are interested in for adjacency checking
    // We are storing this information in one central location to support easy modification
    // by a project. All adjacency types will call through the data manager, which will
    // patch them all of to the same deserialization function, which will then pass them all
    // to the same function in FeatureAdjacencyTask, which will then differentiate on type.
    //FeatureAdjacencyTask::Config2 config = GetAdjacencyTypes();
    //for(size_t i = 0; i < config.size(); ++i)
    //    mgr.AddParam(std::get<0>(config[i]), StaticCallback<void, DataManager::DataInfo>(&SetAdjacencyInfo));

    // Our completion and reset functions
    mgr.SetCompletionCallback(std::bind(&BEML_EMUDLLModel::IsComplete, this));
    mgr.SetResetCallback(std::bind(&BEML_EMUDLLModel::Reset, this));

    // Go speed racer.
    Model().initialize();

    // Scheduler, if models are compiled to be able to run independently
#ifdef MT
    auto &task_counters = Model().getRTM()->Timing.TaskCounters;
    for(auto &tid : task_counters.TID)
        tid = task_counters.cLimit[&tid - &task_counters.TID[0]];
#endif

    // Initialize the memory map after the model is initialized. That way all sizes/pointers should be set up
    m_memory_map.reset(new MemoryMapping(Model()));
    InitializeMemoryMap(*m_memory_map, *this);
    m_serialised_memory.reset(new SerialisedMemoryMapping(*m_memory_map, Registration::GetModelVersion()));

    DLLModel::Log("Press 'd' to dump model state to file");
}

/// Called on initialization of the DLL to register the desired processing tasks (which
/// are called at the beginning and end of every cycle).
///
/// @param pmgr  The manager to register the tasks with

void BEML_EMUDLLModel::SetupProcessing(ProcessingManager &mgr)
{
    mgr.AddTask(&m_feature_task);
}

/// To be called when initialization has been completed. This is our chance to prune the
/// object tree of any unnecessary objects, such as extra vehicles.

void BEML_EMUDLLModel::CompleteInitialization()
{
    // Initialization is complete, so we need to work out how many
    // vehicles we should have, and then prune all remaining vehicles.
    // Cruise through the ObjectDB and list all vehicles with an index
    // greater than or equal to our number of vehicles. Then, remove
    // them at the end (when we are no longer using the iterator).
    vector<Sim::ObjectID> remove_ids;
    for(ObjectDB::Iterator iter = m_object_db.Begin(); iter != m_object_db.End(); ++iter)
    {
        // If the class of this object is a vehicle, check its index
        if(iter->class_id == Project::ClassID::VEHICLE)
        {
            // If the index is too high, add this to our list.
            if(GetNumberInitial(*iter, Project::ValueName::Vehicle::INDEX, m_num_vehicles) >= m_num_vehicles)
                remove_ids.push_back(iter->our_id);
        }
        else if(iter->class_id == Project::ClassID::COUPLING)
        {
           // We need to understand what vehicle we are on before we do anythng ...
           auto parent_iter = std::find_if(m_object_db.Begin(), m_object_db.End(), [iter](const ObjectDB::ObjectInfo &oi) { return oi.our_id == iter->parent_id; });
           if(parent_iter != m_object_db.End())
           {
               // We also need to understand the orientation of this vehicle, and the
               // end that this coupling object pertains to
               const double vehicle_index       = GetNumberInitial(*parent_iter, Project::ValueName::Vehicle::INDEX, m_num_vehicles);
               const double vehicle_orientation = GetNumberValue(*parent_iter, Project::ValueName::Vehicle::ORIENTATION, 0);
               const double one_end             = GetNumberValue(*iter, Project::ValueName::Coupling::END, 1.0);

               // We want to remove all except the coupling objects on the extremities
               // of the train.
               if(!(((vehicle_index == 0)                   && ((vehicle_orientation != 1.0) ^ (one_end == 1.0))) ||
                   (((vehicle_index + 1) == m_num_vehicles) && ((vehicle_orientation == 1.0) ^ (one_end == 1.0)))))
                   remove_ids.push_back(iter->our_id); 
           }  
        }  
    }

    // Now remove the objects that we no longer want. We will have
    // traversed the DB in a topological order from top down (that is,
    // always the parent before the child). We should remove these in
    // reverse (to remove the child before the parent). Removing the
    // parent will automatically remove the child too, but ObjectDB
    // will throw an exception then when we try to remove a child that
    // has already been removed.
    for(auto iter = remove_ids.rbegin(); iter != remove_ids.rend(); ++iter)
        m_object_db.RemoveObject(*iter);

    // We then need to set up our variable mappings (but we only do
    // this after the extraneous mappings for the non-existent vehicles
    // have been removed).
    m_mapper.Populate(m_object_db);
}

void BEML_EMUDLLModel::RunCycle()
{
    m_cycle_timer.RunCycleStart();

    m_cb_manager.BeginCycle(gs_time, gs_iterations, gs_state);
    m_proc_manager.BeginCycle(gs_time);

    // !!! FOR State, we must reset the timers too

    // Scheduler, if models are compiled to be able to run independently
#ifdef MT
    // This is the same as the example source file rt_cppclass_main.cpp, which calls these in rt_OneStep
    // We use the RTM information to work out how many models there are and their frequencies (Timing.TaskCounters.cLimit),
    // and then use the XXX_step function, which basically uses Timing.TaskCounters.TID as a counter, and only calls step() when it is 0
    // The alternative to XXX_step is to generate this code.
    auto &task_counters = GetModel().Model().getRTM()->Timing.TaskCounters;
    for(auto &tid : task_counters.TID)
    {
        if(--tid == 0)
        {
            tid = task_counters.cLimit[&tid - &task_counters.TID[0]];
            BEML_EMU_step(GetModel().Model(), &tid - &task_counters.TID[0]);
        }
    } #s
#else
    Model().step();
#endif

    bool dump = false;
        
    // Testing the console for buffer input can prove to be quite time consuming if there is
    // relatively high CPU on the computer, with lots of threads and context switching, so we
    // need to reduce the frequency that we do this at.
    // We give the possibility to dump at any time though, in case we one day allow triggering of
    // this by means other than the keyboard.
    if(++m_kb_timer == KEYBOARD_CHECK_COUNT)
    {
        while(_kbhit())
        {
            int ch = _getch();
            if(ch == 'd')
                dump = true;
        }

        // Reset the timer so that it will start counting up again
        m_kb_timer = 0;
    }

    if(dump)
    {
        std::string filename = "Dump_" + std::string(Registration::GetModelTitle());
        std::string filename_json = filename + ".json";
        std::string filename_bin  = filename + ".bin";

        // Immediate dump
        {
            DLLModel::Log("Dumping to " + filename_json);
            std::ofstream f(filename_json);
            m_memory_map->Dump(f);
        }
        // Dump of binary for possible later analysis
        {
            DLLModel::Log("Dumping to " + filename_bin);
            std::ofstream f(filename_bin, std::ios::out | std::ios::binary);
            std::vector<uint8_t> buffer;
            buffer.resize(GetState(nullptr, 0));
            if(!buffer.empty())
            {
                GetState(&buffer[0], buffer.size());
                f.write(reinterpret_cast<const char*>(&buffer[0]), buffer.size());
            }
        }
    }

#ifdef LOG_TO_FILE

    bool dolog = false;
    // If we are not currently stable and the Train Model has initilised then set our stable state to true
    if(!mx_stable && ModelOutputs().ModelStatus.IsInitialized)
    {
        mx_stable = true;
        dolog = true;
    }

    if(ModelInputs().SimData.SimulationTime == 0)
    {
        m_log_timer = 0;
    }
    else if(++m_log_timer == LOG_CHECK_COUNT)
    {
        dolog = true;
        m_log_timer = 0;
    }
    
    static bool firsttime = true;
    static int LOG_CARS_SIZE = 4;
    static int log_cars[4] = {1,2,3,8};

    if(dolog)
    {
        if(firsttime)
        {
            // Update with logging data as required
            m_log << "Time" << ",";
            m_log << "Accelerometer" << ",";
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "Position_Car"        << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "Velocity_Car"        << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "Acceleration_Car"    << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "CouplerForce_Car"    << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "SpringForce_Car"     << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "DampingForce_Car"    << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "CouplerExt_Car"      << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "CouplerExtRate_Car"  << log_cars[i] << ","; }
            for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << "TractiveForce_Car"   << log_cars[i] << ","; }
            m_log << std::endl;
            firsttime = false;
        }
        m_log << ModelInputs().SimData.SimulationTime << ",";
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Inertia.Position          << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Inertia.Velocity          << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Inertia.Acceleration      << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Couplers[0].Force         << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Couplers[0].SpringForce   << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Couplers[0].DampingForce  << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Couplers[0].Extension     << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Dynamics.Couplers[0].ExtensionRate << ","; }
        for (int i = 0; i < LOG_CARS_SIZE; i++) { m_log << ModelOutputs().VehicleOutput[log_cars[i]-1].Traction.PhysicalSignals.TotalTractionDBEffort << ","; }
        m_log << std::endl;
    }
#else
    // If we are not currently stable and the Train Model has initilised then set our stable state to true
    if(!mx_stable && ModelOutputs().ModelStatus.IsInitialized)
        mx_stable = true;

#endif //LOG_TO_FILE


    m_cb_manager.EndCycle(gs_time, gs_iterations, gs_state);
    m_proc_manager.EndCycle(gs_time);

    m_cycle_timer.RunCycleEnd(GetPeriod());
}

ModelAllocator &GlobalModelAllocator()
{
    static StandardModelAllocator<BEML_EMUDLLModel> s_allocator;
    return s_allocator;
}
